## 纯AI 学数据库内核开发 | 第一章：存储引擎与数据组织 - 1.1 行存储与页面结构  
  
### 作者  
digoal  
  
### 日期  
2025-02-19  
  
### 标签  
PostgreSQL , PolarDB , DuckDB , AI , 内核 , 学习  
  
----  
  
## 背景  
  
### 第一章：存储引擎与数据组织

---

#### **1.1 行存储与页面结构**

---

##### **理论部分**

###### **Heap Tuple结构**
PostgreSQL使用**堆表（Heap Table）**存储数据行（Tuple），每个Tuple由`HeapTupleHeader`和实际数据组成：
- **头信息（Header）**：包含事务ID（xmin/xmax）、事务状态标记（t_infomask）、字段数量（t_natts）等。
- **数据部分**：按字段顺序存储实际数据，支持对齐填充（Alignment Padding）以提高访问效率。

**示例代码**（简化的内存布局）：
```c
// src/include/access/htup_details.h
struct HeapTupleHeaderData {
    union {
        HeapTupleFields t_heap;
        DatumTupleFields t_datum;
    } t_choice;
    ItemPointerData t_ctid;   // 当前元组的位置（块号+偏移量）
    uint16      t_infomask2;  // 属性数量、标志位
    uint16      t_infomask;   // 事务状态标志位
    uint8       t_hoff;       // 头长度
    bits8       t_bits[FLEXIBLE_ARRAY_MEMBER];  // NULL位图（可选）
};
```

###### **PageHeader字段解析**
每个数据页（Page）大小为8KB，由`PageHeader`、行指针（Line Pointer）和实际数据组成：
- **PageHeader**：存储页面元信息，关键字段如下：
  ```c
  // src/include/storage/bufpage.h
  typedef struct PageHeaderData {
      PageXLogRecPtr pd_lsn;    // 最后修改的LSN（日志序列号）
      uint16      pd_checksum;  // 页面校验和（可选）
      uint16      pd_flags;     // 标志位（如是否压缩）
      LocationIndex pd_lower;   // 空闲空间起始位置
      LocationIndex pd_upper;   // 空闲空间结束位置
      LocationIndex pd_special; // 特殊空间起始位置（如索引页的B-Tree元数据）
      uint16      pd_pagesize_version;  // 页面大小和版本号
      TransactionId pd_prune_xid; // 可修剪的最早事务ID
  } PageHeaderData;
  ```
- **行指针（Line Pointer）**：每个行指针（4字节）指向页面内实际数据行的偏移量和长度。

###### **页面组织方式**
- **链表结构**：通过`pd_lower`和`pd_upper`管理空闲空间，新插入的数据从`pd_upper`向`pd_lower`方向分配。
- **B-Tree索引页**：在索引页中，`pd_special`指向B-Tree元数据（如左右兄弟指针、层级信息）。

---

##### **PG代码分析**

1. **页面布局定义**  
   在`src/include/storage/bufpage.h`中，`PageHeaderData`定义了页面头部的字段。数据行的存储从`pd_lower`开始，行指针从`pd_upper`结束位置反向增长。

2. **行插入逻辑**  
   查看`src/backend/storage/page/heapam.c`中的`heap_insert`函数，了解如何分配空间、更新行指针和页面头部。

---

##### **基础实验**

###### **实验1：使用pageinspect查看页面结构**
1. 安装扩展：
   ```sql
   CREATE EXTENSION pageinspect;
   ```
2. 查看页面头信息：
   ```sql
   SELECT * FROM page_header(get_raw_page('my_table', 0));  -- 查看第0号页面头
   ```
3. 查看行指针和实际数据：
   ```sql
   SELECT lp, t_data FROM heap_page_items(get_raw_page('my_table', 0));
   ```

###### **实验2：修改pd_lsn模拟页面损坏**
1. **编写C函数（需在PG源码树中编译）**  
   ```c
   #include "postgres.h"
   #include "storage/bufpage.h"

   PG_MODULE_MAGIC;

   PG_FUNCTION_INFO_V1(corrupt_page);
   Datum corrupt_page(PG_FUNCTION_ARGS) {
       PageHeader page = (PageHeader) PG_GETARG_POINTER(0);
       page->pd_lsn = 0;  // 将LSN置零，模拟损坏
       PG_RETURN_VOID();
   }
   ```
2. **编译并加载函数**  
   ```bash
   # 编译为corrupt_page.so
   gcc -I$(pg_config --includedir-server) -shared -o corrupt_page.so corrupt_page.c
   ```
3. **触发恢复**  
   ```sql
   -- 加载函数
   CREATE FUNCTION corrupt_page(INTERNAL) RETURNS VOID AS 'corrupt_page.so' LANGUAGE C;
   -- 修改页面并触发恢复（需在测试环境中谨慎操作！）
   SELECT corrupt_page(get_raw_page('my_table', 0));
   ```
4. **调试与验证**  
   - **GDB调试**：
     ```bash
     gdb --args postgres -D /path/to/data
     (gdb) break corrupt_page
     (gdb) print page->pd_lsn  # 观察修改后的值
     ```
   - **Valgrind检查内存泄漏**：
     ```bash
     valgrind --leak-check=yes --track-origins=yes postgres -D /path/to/data
     ```

---

##### **厂商扩展实验**

###### **MySQL InnoDB的COMPACT行格式**
- **关键结构**：变长字段长度列表、NULL位图、事务ID、回滚指针。
- **验证方法**：
  ```sql
  CREATE TABLE t (a INT, b VARCHAR(10)) ROW_FORMAT=COMPACT;
  -- 使用hexdump查看表空间文件
  hexdump -C /var/lib/mysql/test/t.ibd
  ```

###### **SQLite页面结构**
- **B-Tree页面布局**：页面头（类型、空闲块数）、Cell指针数组、实际数据Cell。
- **验证方法**：
  ```bash
  sqlite3 test.db
  .dbinfo          # 查看数据库信息
  .dump            # 导出页面结构
  ```

###### **DuckDB向量化页面布局**
- **向量化存储**：按列存储数据，每列划分为固定大小的向量（Vector）。
- **验证方法**：
  ```python
  import duckdb
  conn = duckdb.connect(":memory:")
  conn.execute("CREATE TABLE t (a INT, b VARCHAR)")
  # 使用PRAGMA查看存储格式
  print(conn.execute("PRAGMA storage_info('t')").fetchall())
  ```

---

##### **练习题**
1. **代码分析**：在`src/backend/storage/page/heapam.c`中找到`heap_insert`函数，画出插入数据时的页面布局变化流程图。
2. **实验验证**：使用`pageinspect`查看一个包含NULL值的表，观察NULL位图如何表示缺失字段。
3. **扩展思考**：如果PostgreSQL的页面大小改为16KB，需要修改哪些代码？（提示：搜索`BLCKSZ`定义）

---

##### **注意事项**
- **代码修改风险**：修改`pd_lsn`可能导致数据库崩溃！务必在测试环境中操作并备份数据。
- **二次确认方法**：对于未明确标注的代码路径，建议通过GDB单步调试或添加日志（`elog(INFO, ...)`）验证执行流程。
  
<b> 以上内容基于DeepSeek-R1和Gemini 2.0 Flash生成, 轻微人工调整, 感谢 杭州深度求索人工智能基础技术研究有限公司 及 google </b>  
  
  
  
#### [期望 PostgreSQL|开源PolarDB 增加什么功能?](https://github.com/digoal/blog/issues/76 "269ac3d1c492e938c0191101c7238216")
  
  
#### [PolarDB 开源数据库](https://openpolardb.com/home "57258f76c37864c6e6d23383d05714ea")
  
  
#### [PolarDB 学习图谱](https://www.aliyun.com/database/openpolardb/activity "8642f60e04ed0c814bf9cb9677976bd4")
  
  
#### [PostgreSQL 解决方案集合](../201706/20170601_02.md "40cff096e9ed7122c512b35d8561d9c8")
  
  
#### [德哥 / digoal's Github - 公益是一辈子的事.](https://github.com/digoal/blog/blob/master/README.md "22709685feb7cab07d30f30387f0a9ae")
  
  
#### [About 德哥](https://github.com/digoal/blog/blob/master/me/readme.md "a37735981e7704886ffd590565582dd0")
  
  
![digoal's wechat](../pic/digoal_weixin.jpg "f7ad92eeba24523fd47a6e1a0e691b59")
  
