## 纯AI 学数据库内核开发 | 第一章：存储引擎与数据组织 - 1.1 行存储与页面结构  
  
### 作者  
digoal  
  
### 日期  
2025-02-19  
  
### 标签  
PostgreSQL , PolarDB , DuckDB , AI , 内核 , 学习  
  
----  
  
## 背景  
  
# 第一章：存储引擎与数据组织 - 1.1 行存储与页面结构  
  
欢迎来到数据库内核开发的世界！存储引擎是数据库的核心组件之一，它负责管理数据的持久化存储。今天，我们将深入探讨行存储的原理和页面结构，这是理解 PostgreSQL 存储机制的基础。  
  
## 1. 理论：行存储与页面结构  
  
### 1.1 行存储概述  
  
行存储 (Row-oriented storage) 是一种常见的数据库存储方式，它将表中的每一行数据作为一个整体存储在磁盘上。 这种存储方式的优点是：  
  
*   **适合事务处理**：可以快速读取或修改整行数据。  
*   **简单易懂**：数据组织方式直观，容易理解。  
  
但是，行存储在分析型查询 (OLAP) 场景下效率较低，因为分析型查询通常只需要访问表中的少数几列数据，而行存储需要读取整行数据，造成了大量的 I/O 浪费。  
  
### 1.2 Heap Tuple 结构  
  
在 PostgreSQL 中，每一行数据被称为一个 Heap Tuple。Heap Tuple 包含了用户数据和一些元数据，用于管理行的版本和可见性。  
  
Heap Tuple 的基本结构如下：  
人工注解: 此结构有错误. 详见 `src/include/access/htup_details.h`   
  
```c  
typedef struct HeapTupleHeaderData {  
    /* -- start of common fields -- */  
  
    TransactionId t_xmin;       /* inserting xact ID */  
    Oid         t_cid;          /* inserting command ID, or zero */  
  
    TransactionId t_xmax;       /* deleting or locking xact ID */  
    Oid         t_cmax;          /* deleting command ID, or zero */  
  
    CommandId t_field3;         /* per-tuple storage for use by tuple locking */  
  
    /* -- end of common fields, beginning of optional fields -- */  
  
    /*  
     * t_ctid is not optional; it's present in every tuple header.  
     */  
    ItemPointerData t_ctid;     /* current TID (usually self) */  
  
    /* optional fields start here */  
    DatumId t_datumId;          /* datum identifier */  
  
    /* add more optional fields here */  
  
    /*  
     * Actual heap tuple data follows this header.  
     */  
} HeapTupleHeaderData;  
```  
  
*   **`t_xmin`**: 插入事务的 ID。  
*   **`t_cid`**: 插入命令的 ID。  
*   **`t_xmax`**: 删除事务的 ID。如果该元组未被删除，则为 0。  
*   **`t_cmax`**: 删除命令的 ID。  
*   **`t_field3`**: 用于元组锁定的每元组存储空间。  
*   **`t_ctid`**: 当前元组的 TID (Tuple ID)，通常指向自身。在更新操作中，`t_ctid` 会指向新元组。  
*   **用户数据**: 实际存储的列数据。  
  
### 1.3 PageHeader 字段解析  
  
PostgreSQL 将数据存储在固定大小的页面 (Page) 中，通常为 8KB。 每个页面都包含一个 PageHeader，用于管理页面上的元组和空闲空间。  
  
PageHeader 的结构定义在 `src/include/storage/bufpage.h` 中：  
  
```c  
typedef struct PageHeaderData {  
    /*  
     * 共用字段起始  
     */  
  
    PageXLogRecPtr pd_lsn;      /* 页面最后一次修改的 LSN */  
    uint16      pd_checksum;    /* 页面的校验和 */  
    uint16      pd_flags;       /* 标志位 */  
    uint16      pd_lower;       /* 页面中已使用的空间的起始位置 */  
    uint16      pd_upper;       /* 页面中空闲空间的起始位置 */  
    uint16      pd_special;     /* 页面中特殊空间的起始位置 */  
    uint16      pd_pagesize_version; /* 页面大小和版本信息 */  
    TransactionId pd_prune_xid;    /* 页面修剪的 XID */  
    /*  
     * 共用字段结束  
     */  
} PageHeaderData;  
```  
  
*   **`pd_lsn`**: 页面最后一次修改的 LSN (Log Sequence Number)。LSN 用于 WAL (Write-Ahead Logging) 机制，保证数据的一致性和持久性。  
*   **`pd_checksum`**: 页面的校验和，用于检测页面是否损坏。  
*   **`pd_flags`**: 标志位，用于表示页面的状态，例如是否已满、是否需要清理等。  
*   **`pd_lower`**: 页面中已使用的空间的起始位置，指向页面中第一个元组的起始位置。  
*   **`pd_upper`**: 页面中空闲空间的起始位置，指向页面中最后一个元组的结束位置。  
*   **`pd_special`**: 页面中特殊空间的起始位置，用于存储索引信息或其他特殊数据。  
*   **`pd_pagesize_version`**: 页面大小和版本信息。  
*   **`pd_prune_xid`**: 页面修剪的 XID。  
  
### 1.4 页面组织方式  
  
PostgreSQL 使用多种方式组织页面，包括：  
  
*   **链表**：用于组织 Heap Page，每个页面通过 `pd_lsn` 字段指向下一个页面。  
*   **B-Tree**：用于组织索引页面，提供快速的查找能力。  
  
Heap Page 的组织方式比较简单，每个页面都包含一些元组和空闲空间。 当插入新的元组时，PostgreSQL 会在页面中找到足够的空闲空间，并将元组插入到页面中。 当删除元组时，PostgreSQL 会将元组标记为已删除，但不会立即回收空间。 空间回收由 VACUUM 进程负责。  
  
## 2. PG 代码分析  
  
### 2.1 `src/include/storage/bufpage.h`  
  
这个头文件定义了 PageHeaderData 结构，以及一些操作页面的宏和函数。  
  
仔细阅读这个文件，可以了解 PageHeader 中各个字段的含义，以及如何操作页面。  
  
### 2.2 `src/backend/storage/page/` 目录下的相关代码  
  
这个目录下包含了操作页面的相关代码，例如：  
  
*   **`page.c`**: 包含了创建、读取、修改页面的函数。  
*   **`heapam.c`**: 包含了操作 Heap Tuple 的函数。  
  
通过阅读这些代码，可以了解 PostgreSQL 如何管理页面和元组。  
  
## 3. 基础实验  
  
### 3.1 使用 `pageinspect` 扩展查看 PG 数据页二进制结构  
  
`pageinspect` 是一个 PostgreSQL 扩展，可以用于查看数据页的二进制结构。  
  
1.  **安装 `pageinspect` 扩展**：  
  
    ```sql  
    CREATE EXTENSION pageinspect;  
    ```  
  
2.  **创建一个测试表**：  
  
    ```sql  
    CREATE TABLE test_table (id serial primary key, name text);  
    INSERT INTO test_table (name) VALUES ('test');  
    ```  
  
3.  **找到测试表的页面**：  
  
    ```sql  
    SELECT relname, relpages FROM pg_class WHERE relname = 'test_table';  
    ```  
  
    这会返回测试表的页面数量。通常情况下，一个小的表只占用一个页面。  
  
4.  **使用 `pageinspect` 查看页面内容**：  
  
    ```sql  
    SELECT * FROM page_header(get_raw_page('test_table', 0));  
    ```  
  
    这会返回测试表的第一个页面的 PageHeader 信息。 你可以查看 `pd_lsn`, `pd_checksum`, `pd_flags`, `pd_lower`, `pd_upper`, `pd_special` 等字段的值。  
  
    ```sql  
    SELECT * FROM heap_page_item(get_raw_page('test_table', 0));  
    ```  
  
    这会返回测试表中第一个页面的所有元组的信息。 你可以查看 `t_xmin`, `t_xmax`, `t_ctid` 等字段的值，以及元组的数据。  
  
### 3.2 编写 C 函数修改 `pd_lsn` 模拟页面损坏并触发恢复  
  
这个实验旨在让你了解 PostgreSQL 的 WAL 机制。  
  
1.  **创建一个 C 函数**：  
  
    ```c name=corrupt_page.c  
    #include "postgres.h"  
    #include "fmgr.h"  
    #include "access/xlog.h"  
    #include "storage/bufmgr.h"  
  
    PG_MODULE_MAGIC;  
  
    PG_FUNCTION_INFO_V1(corrupt_page);  
  
    Datum  
    corrupt_page(PG_FUNCTION_ARGS)  
    {  
        text     *relname = PG_GETARG_TEXT_P(0);  
        int32   page_number = PG_GETARG_INT32(1);  
  
        Relation rel;  
        Buffer buf;  
        Page page;  
        PageHeaderData *header;  
  
        rel = RelationNameGetRelation(relname);  
        if (!RelationIsValid(rel))  
            ereport(ERROR,  
                    (errcode(ERRCODE_UNDEFINED_TABLE),  
                     errmsg("relation \"%s\" does not exist", relname)));  
  
        buf = ReadBuffer(rel, page_number);  
        page = BufferGetPage(buf);  
        LockBuffer(buf, BUFFER_LOCK_EXCLUSIVE);  
  
        header = (PageHeaderData *) page;  
  
        /* corrupt the LSN */  
        header->pd_lsn = 0;  
  
        MarkBufferDirty(buf);  
  
        UnlockReleaseBuffer(buf);  
        RelationClose(rel);  
  
        PG_RETURN_VOID();  
    }  
    ```  
  
    这个 C 函数接收表名和页号作为参数，然后将指定页面的 `pd_lsn` 字段设置为 0，模拟页面损坏。  
  
2.  **编译 C 函数**：  
  
    ```bash  
    gcc -g -fPIC -I /usr/include/postgresql/server -c corrupt_page.c  
    gcc -shared -o corrupt_page.so corrupt_page.o  
    ```  
    替换 `/usr/include/postgresql/server` 为你PostgreSQL的头文件路径.  
  
3.  **创建一个 SQL 函数**：  
  
    ```sql  
    CREATE OR REPLACE FUNCTION corrupt_page(text, int) RETURNS void  
        AS '/path/to/corrupt_page.so', 'corrupt_page'  
        LANGUAGE C STRICT;  
    ```  
    替换 `/path/to/corrupt_page.so` 为你编译出的动态链接库路径.  
  
4.  **调用 SQL 函数，破坏页面**：  
  
    ```sql  
    SELECT corrupt_page('test_table', 0);  
    ```  
  
5.  **重启 PostgreSQL 服务器**：  
  
    重启 PostgreSQL 服务器后，PostgreSQL 会检测到页面损坏，并尝试从 WAL 日志中恢复页面。  
  
6.  **检查 PostgreSQL 日志**：  
  
    查看 PostgreSQL 日志，确认页面恢复成功。  
  
### 3.3 GDB 和 Valgrind 的使用  
  
*   **GDB:** 使用GDB调试C函数，观察变量变化，验证修改是否正确。  
*   **Valgrind:** 使用Valgrind Memcheck检查C函数是否存在内存泄漏。  
  
#### GDB 调试 C 函数  
  
1.  **编译 C 函数时添加 `-g` 选项**：  
    确保在编译 `corrupt_page.c` 时使用了 `-g` 选项，以便生成调试信息。  
  
2.  **启动 GDB 并加载 PostgreSQL**：  
    ```bash  
    gdb /usr/lib/postgresql/14/bin/postgres  
    ```  
    替换 `/usr/lib/postgresql/14/bin/postgres` 为你的 PostgreSQL 服务器二进制文件路径。  
  
3.  **连接到 PostgreSQL 进程**：  
    找到 PostgreSQL 的 PID 并使用 `attach` 命令连接到该进程。  
    ```gdb  
    attach <pid>  
    ```  
  
4.  **设置断点**：  
    在 `corrupt_page` 函数中设置断点，例如在修改 `pd_lsn` 的行上设置断点。  
    ```gdb  
    break corrupt_page.c:27  
    ```  
  
5.  **调用 SQL 函数**：  
    在 `gdb` 连接到 postgres 进程后，通过 `psql` 调用 `corrupt_page` 函数。  
    ```sql  
    SELECT corrupt_page('test_table', 0);  
    ```  
  
6.  **观察变量变化**：  
    当程序在断点处暂停时，使用 `print` 命令查看变量的值，例如 `header->pd_lsn`。  
    ```gdb  
    print header->pd_lsn  
    ```  
  
7.  **单步执行**：  
    使用 `next` 或 `step` 命令单步执行程序，观察每一步的变化。  
  
#### Valgrind 检查 C 函数  
  
1.  **使用 Valgrind 运行 PostgreSQL**：  
    ```bash  
    valgrind --leak-check=full /usr/lib/postgresql/14/bin/postgres -D /path/to/your/data/directory  
    ```  
    替换 `/usr/lib/postgresql/14/bin/postgres` 为你的 PostgreSQL 服务器二进制文件路径，`/path/to/your/data/directory` 为你的数据目录路径。 这种方式会启动一个新的PostgreSQL实例, 可能会和现有的实例冲突.  
  
2.  **连接到 PostgreSQL 进程并调用 SQL 函数**：  
    保持Valgrind运行, 另起一个终端, 连接到PostgreSQL实例, 调用 `corrupt_page` 函数。  
    ```sql  
    SELECT corrupt_page('test_table', 0);  
    ```  
  
3.  **观察 Valgrind 的输出**：  
    Valgrind 会报告内存泄漏和其他内存错误。 确保 `corrupt_page` 函数没有内存泄漏。  
  
## 4. 厂商扩展实验  
  
### 4.1 (MySQL) 分析 InnoDB 的 COMPACT 行格式  
  
InnoDB 是 MySQL 的默认存储引擎，它使用 COMPACT 行格式存储数据。  
  
COMPACT 行格式的结构如下：  
  
*   **Record Header**：记录头，包含记录的元数据，例如记录的类型、删除状态等。  
*   **变长字段长度列表**：存储变长字段的长度。  
*   **NULL 值列表**：存储 NULL 值的字段。  
*   **用户数据**：实际存储的列数据。  
  
通过分析 COMPACT 行格式，可以了解 InnoDB 如何存储和管理数据。  
  
### 4.2 (SQLite) 分析 SQLite 的页面结构和 B-Tree 实现  
  
SQLite 是一个嵌入式数据库，它使用 B-Tree 存储数据。  
  
SQLite 的页面结构如下：  
  
*   **Page Header**：页面头，包含页面的元数据，例如页面类型、空闲空间等。  
*   **Cell Pointer Array**：指向页面中 Cell 的指针数组。  
*   **Cell Content Area**：存储 Cell 的内容，Cell 包含实际的数据。  
*   **Free Space**：空闲空间。  
  
通过分析 SQLite 的页面结构和 B-Tree 实现，可以了解 SQLite 如何组织和查找数据。  
  
### 4.3 (DuckDB) 分析 DuckDB 的行存储格式和向量化执行的页面布局  
  
DuckDB 是一个面向分析的数据库，它使用行存储格式和向量化执行技术。  
  
DuckDB 的页面布局如下：  
  
*   **Header**：页面头，包含页面的元数据。  
*   **Vectors**：存储列数据的向量。每个向量包含相同类型的数据。  
  
通过分析 DuckDB 的页面布局，可以了解 DuckDB 如何利用向量化执行技术提高查询性能。  
  
## 总结  
  
通过本节课的学习，你应该已经掌握了行存储的原理和页面结构，以及 PostgreSQL 如何管理页面和元组。 通过实践实验，你可以更深入地理解这些概念，并为后续的数据库内核开发打下坚实的基础。  
  
记住，理解存储引擎是数据库内核开发的关键。 深入研究 PostgreSQL 的存储机制，你将能够更好地理解数据库的内部运作，并开发出更高效的数据库应用。  
  
  
<b> 以上内容基于DeepSeek-R1和Gemini 2.0 Flash生成, 轻微人工调整, 感谢 杭州深度求索人工智能基础技术研究有限公司 及 google </b>  
  
  
