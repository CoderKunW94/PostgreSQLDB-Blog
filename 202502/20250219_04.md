## 纯AI 学数据库内核开发 | 第一章：存储引擎与数据组织 - 1.1 行存储与页面结构  
  
### 作者  
digoal  
  
### 日期  
2025-02-19  
  
### 标签  
PostgreSQL , PolarDB , DuckDB , AI , 内核 , 学习  
  
----  
  
## 背景  
  
# **第一章：存储引擎与数据组织**

## **1.1 行存储与页面结构**

### 理论：Heap Tuple结构、PageHeader字段解析、页面组织方式（链表、B-Tree等）

**行存储** 是数据库中最基础的存储方式之一。在行存储中，数据按行组织，每一行包含所有列的值。PostgreSQL (PG) 采用行存储作为其主要存储方式，并使用堆表 (Heap Table) 来存储数据。理解行存储和页面结构是深入理解数据库内核的基础。

*   **Heap Tuple 结构**

    在 PostgreSQL 中，每一行数据被称为一个 Heap Tuple。Heap Tuple 包含实际的数据以及一些元数据，用于管理和维护数据行的状态。Heap Tuple 的主要结构如下：

    *   `t_xmin`: 插入事务的 ID。
    *   `t_xmax`: 删除事务的 ID (如果该行被删除)。
    *   `t_cid`: 插入命令的 ID。
    *   `t_xvac`: VACUUM 事务的 ID。
    *   `t_ctid`: 指向自身或新行的指针 (用于更新)。
    *   `t_infomask2`: 包含有关 Tuple 状态的标志位。
    *   `t_infomask`: 包含有关 Tuple 状态的标志位和锁信息。
    *   `t_len`: Tuple 的数据长度。
    *   Data: 实际的数据内容。

    理解这些字段对于理解 PostgreSQL 的 MVCC (多版本并发控制) 至关重要。

*   **PageHeader 字段解析**

    在 PostgreSQL 中，数据存储在固定大小的页面 (通常为 8KB) 中。每个页面都有一个 PageHeader，用于存储页面的元数据。PageHeader 包含以下重要字段：

    *   `pd_lsn`: 页面最后一次修改的日志序列号 (LSN)。用于 WAL (预写式日志) 恢复。
    *   `pd_checksum`: 页面的校验和，用于检测页面损坏。
    *   `pd_flags`: 页面标志位，例如页面是否已满、是否包含空闲空间等。
    *   `pd_lower`: 指向页面中已使用空间的起始位置。
    *   `pd_upper`: 指向页面中空闲空间的起始位置。
    *   `pd_special`: 指向页面中特殊区域的起始位置 (例如，索引页面的 B-Tree 元数据)。
    *   `pd_pagesize_version`: 页面大小和版本信息。
    *   `pd_prune_xid`: 用于 VACUUM 操作的事务 ID。

    PageHeader 的结构定义在 `src/include/storage/bufpage.h` 中。

*   **页面组织方式（链表、B-Tree 等）**

    PostgreSQL 使用多种方式组织页面，主要包括：

    *   **链表**：堆表中的数据页面通过链表连接。当需要顺序扫描整个表时，可以通过链表遍历所有页面。
    *   **B-Tree**：索引页面使用 B-Tree 结构组织。B-Tree 是一种自平衡树结构，可以高效地进行查找、插入和删除操作。

    页面组织方式的选择取决于具体的存储对象和访问模式。堆表主要使用链表，而索引使用 B-Tree。

### PG 代码分析：`src/include/storage/bufpage.h` 中 Page 布局、`src/backend/storage/page/` 目录下的相关代码

*   **`src/include/storage/bufpage.h`**

    这个头文件定义了 PageHeaderData 结构，描述了页面的布局。以下是 `PageHeaderData` 的简化版本：

    ```c
    typedef struct PageHeaderData
    {
        PageXLogRecPtr pd_lsn;     /* LSN: next block version */
        uint16      pd_checksum;    /* checksum for whole page */
        uint16      pd_flags;       /* flag bits, see below */
        uint16      pd_lower;       /* offset to start of free space */
    uint16      pd_upper;       /* offset to end of free space */
    uint16      pd_special;     /* offset to start of special space */
    uint16      pd_pagesize_version;
    pg_xid      pd_prune_xid;   /* oldest XID among potentially prunable tuples on page */
    } PageHeaderData;
    ```

    通过阅读这个头文件，可以清晰地了解 PageHeader 中各个字段的含义和布局。

*   **`src/backend/storage/page/` 目录**

    这个目录包含与页面管理相关的代码。一些重要的文件包括：

    *   `bufpage.c`：包含用于操作缓冲页面的函数，例如 `PageGetFreeSpace()` 用于获取页面的空闲空间。
    *   `itemptr.c`：包含用于操作 ItemPointer 的函数，ItemPointer 用于指向页面中的 Tuple。
    *   `pageutil.c`：包含一些页面相关的工具函数，例如页面初始化和页面校验。

    通过阅读这些代码，可以深入了解 PostgreSQL 如何管理和操作数据页面。

### 基础实验：

*   **使用 `pageinspect` 扩展查看 PG 数据页二进制结构**

    `pageinspect` 是 PostgreSQL 的一个扩展，可以用于检查页面的内部结构。要使用 `pageinspect`，首先需要安装它：

    ```sql
    CREATE EXTENSION pageinspect;
    ```

    然后，可以使用 `get_raw_page()` 函数获取页面的二进制内容，并使用 `page_header()` 函数解析 PageHeader。

    例如，要查看 `mytable` 的第一个数据页，可以执行以下步骤：

    1.  找到 `mytable` 的 OID (对象 ID)：

        ```sql
        SELECT oid FROM pg_class WHERE relname = 'mytable';
        ```

    2.  使用 `get_raw_page()` 获取页面的二进制内容：

        ```sql
        SELECT get_raw_page('mytable', 0);  -- 0 是页面号
        ```

    3.  使用 `page_header()` 解析 PageHeader：

        ```sql
        SELECT * FROM page_header(get_raw_page('mytable', 0));
        ```

    通过这些步骤，可以查看页面的 LSN、校验和、空闲空间等信息。

*   **编写 C 函数修改 `pd_lsn` 模拟页面损坏并触发恢复**

    要编写 C 函数修改 `pd_lsn`，需要创建一个 PostgreSQL 扩展。以下是一个简单的示例：

    1.  创建一个目录 `page_corrupt`，并在其中创建 `page_corrupt.c`、`page_corrupt.control` 和 `Makefile`。

    2.  `page_corrupt.c` 的内容如下：

        ```c
        #include "postgres.h"
        #include "fmgr.h"
        #include "access/xlog.h"
        #include "storage/bufmgr.h"
        #include "storage/pageheader.h"

        PG_MODULE_MAGIC;

        PG_FUNCTION_INFO_V1(corrupt_page);

        Datum
        corrupt_page(PG_FUNCTION_ARGS)
        {
            Oid relid = PG_GETARG_OID(0);
            int blockno = PG_GETARG_INT32(1);

            Buffer buffer;
            Page page;

            buffer = ReadBuffer(relid, blockno);
            LockBuffer(buffer, BUFFER_LOCK_EXCLUSIVE);
            page = BufferGetPage(buffer);

            PageHeaderData *header = (PageHeaderData *) page;
            header->pd_lsn = 0; // 将 LSN 设置为 0，模拟页面损坏

            MarkBufferDirty(buffer);
            UnlockBuffer(buffer);
            ReleaseBuffer(buffer);

            PG_RETURN_VOID();
        }
        ```

    3.  `page_corrupt.control` 的内容如下：

        ```
        # page_corrupt extension
        comment = 'corrupt a page'
        default_version = '1.0'
        module_pathname = '$libdir/page_corrupt'
        relocatable = true
        ```

    4.  `Makefile` 的内容如下：

        ```
        EXTENSION = page_corrupt
        DATA = page_corrupt--1.0.sql
        PGFILEDESCRIPTION = SQL code

        PG_CONFIG = pg_config
        PGXS := $(shell $(PG_CONFIG) --pgxs)
        include $(PGXS)
        ```

    5.  创建 `page_corrupt--1.0.sql` 文件，内容如下：

        ```sql
        CREATE FUNCTION corrupt_page(oid, int) RETURNS void
            AS 'MODULE_PATHNAME', 'corrupt_page'
        LANGUAGE C STRICT;
        ```

    6.  编译并安装扩展：

        ```bash
        make
        make install
        ```

    7.  在 PostgreSQL 中创建扩展：

        ```sql
        CREATE EXTENSION page_corrupt;
        ```

    现在，可以使用 `corrupt_page()` 函数来损坏页面：

    ```sql
    SELECT corrupt_page('mytable'::regclass, 0);
    ```

    这将把 `mytable` 的第一个数据页的 `pd_lsn` 设置为 0，模拟页面损坏。然后，可以尝试重启 PostgreSQL，观察是否触发恢复过程。

    **注意：这个实验可能会导致数据损坏，请在测试环境中使用。**

    *   **GDB:** 使用 GDB 调试 C 函数，观察变量变化，验证修改是否正确。

        可以使用 GDB 调试 `corrupt_page()` 函数，观察 `header->pd_lsn` 的变化。首先，使用 `gdb` 连接到 PostgreSQL 的后端进程：

        ```bash
        gdb -p <pid>
        ```

        然后，在 `corrupt_page()` 函数中设置断点：

        ```gdb
        break corrupt_page
        ```

        运行 SQL 查询 `SELECT corrupt_page('mytable'::regclass, 0);`，当程序执行到断点时，可以使用 `print` 命令查看变量的值：

        ```gdb
        print header->pd_lsn
        ```

        可以使用 `next` 命令单步执行代码，观察变量的变化。

    *   **Valgrind:** 使用 Valgrind Memcheck 检查 C 函数是否存在内存泄漏。

        可以使用 Valgrind Memcheck 检查 `corrupt_page()` 函数是否存在内存泄漏：

        ```bash
        valgrind --leak-check=full ./postgres -D data -c "SELECT corrupt_page('mytable'::regclass, 0);"
        ```

        Valgrind Memcheck 会检查程序在执行过程中是否存在内存泄漏，并输出详细的报告。

### 厂商扩展实验：

*   **(MySQL) 分析 InnoDB 的 COMPACT 行格式。**

    InnoDB 是 MySQL 的默认存储引擎。InnoDB 使用一种称为 COMPACT 的行格式来存储数据。COMPACT 行格式的主要特点包括：

    *   **记录头**：包含记录的元数据，例如记录是否被删除、记录的类型等。
    *   **NULL 值标志位**：用于标记哪些列的值为 NULL。
    *   **变长列长度**：对于变长列，存储列的长度。
    *   **数据**：实际的数据内容。

    COMPACT 行格式的设计目标是减少存储空间，提高性能。

    可以使用 `SHOW CREATE TABLE` 命令查看表的结构，并使用 `hexdump` 命令查看数据页的二进制内容，从而分析 COMPACT 行格式。

*   **(SQLite) 分析 SQLite 的页面结构和 B-Tree 实现。**

    SQLite 是一种轻量级的嵌入式数据库。SQLite 使用页面结构和 B-Tree 实现来存储数据。SQLite 的页面结构包括：

    *   **PageHeader**：包含页面的元数据，例如页面类型、空闲空间等。
    *   **Cell Pointer Array**：包含指向页面中 Cell 的指针。
    *   **Cell**：包含实际的数据内容。

    SQLite 的 B-Tree 实现是一种自平衡树结构，可以高效地进行查找、插入和删除操作。

    可以使用 SQLite 的 `PRAGMA page_size` 命令查看页面大小，并使用 `PRAGMA integrity_check` 命令检查数据库的完整性。可以使用 `sqlite3_analyzer.exe` 工具来分析数据库的页面结构。

*   **(DuckDB) 分析 DuckDB 的行存储格式和向量化执行的页面布局。**

    DuckDB 是一种高性能的分析型数据库。DuckDB 使用行存储格式和向量化执行的页面布局来存储数据。DuckDB 的行存储格式类似于 PostgreSQL 的 Heap Tuple 结构，但进行了一些优化，以提高分析性能。DuckDB 的向量化执行的页面布局将数据按列存储在页面中，可以高效地进行列式操作。

    DuckDB 的页面布局针对向量化执行进行了优化，可以减少内存访问次数，提高 CPU 缓存命中率。

    可以通过阅读 DuckDB 的源代码，了解其行存储格式和向量化执行的页面布局。DuckDB 的源代码可以在 GitHub 上找到。

### 练习方法：

1.  **阅读源代码**：仔细阅读 `src/include/storage/bufpage.h` 和 `src/backend/storage/page/` 目录下的代码，了解页面结构和页面管理的实现细节。
2.  **使用 `pageinspect` 扩展**：使用 `pageinspect` 扩展查看实际的数据页，分析 PageHeader 和 Tuple 的内容。
3.  **编写 C 函数**：编写 C 函数修改页面内容，模拟页面损坏，并观察 PostgreSQL 的恢复过程。
4.  **分析厂商扩展**：分析 MySQL 的 InnoDB、SQLite 和 DuckDB 的存储格式和页面布局，了解不同数据库的存储引擎的特点。
5.  **GDB 调试**：使用 GDB 调试 C 函数，观察变量变化，验证修改是否正确。
6.  **Valgrind 检查**：使用 Valgrind Memcheck 检查 C 函数是否存在内存泄漏。

通过以上步骤，可以深入理解 PostgreSQL 的存储引擎和数据组织方式，为后续的数据库内核开发打下坚实的基础。  
  
<b> 以上内容基于DeepSeek-R1和Gemini 2.0 Flash生成, 轻微人工调整, 感谢 杭州深度求索人工智能基础技术研究有限公司 及 google </b>  
  
  
  
#### [期望 PostgreSQL|开源PolarDB 增加什么功能?](https://github.com/digoal/blog/issues/76 "269ac3d1c492e938c0191101c7238216")
  
  
#### [PolarDB 开源数据库](https://openpolardb.com/home "57258f76c37864c6e6d23383d05714ea")
  
  
#### [PolarDB 学习图谱](https://www.aliyun.com/database/openpolardb/activity "8642f60e04ed0c814bf9cb9677976bd4")
  
  
#### [PostgreSQL 解决方案集合](../201706/20170601_02.md "40cff096e9ed7122c512b35d8561d9c8")
  
  
#### [德哥 / digoal's Github - 公益是一辈子的事.](https://github.com/digoal/blog/blob/master/README.md "22709685feb7cab07d30f30387f0a9ae")
  
  
#### [About 德哥](https://github.com/digoal/blog/blob/master/me/readme.md "a37735981e7704886ffd590565582dd0")
  
  
![digoal's wechat](../pic/digoal_weixin.jpg "f7ad92eeba24523fd47a6e1a0e691b59")
  
